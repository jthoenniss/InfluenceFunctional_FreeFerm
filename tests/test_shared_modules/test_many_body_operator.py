import unittest
import numpy as np
import os,sys
parent_dir = os.path.join(os.path.dirname(__file__),"../..")
#append parent directory to path
sys.path.append(parent_dir)
from src.shared_modules.many_body_operator import many_body_operator, annihilation_ops, idx_sign_under_reverse, indices_odd_and_even, fermion_parity


class TestAnnihilationsOps(unittest.TestCase):
    """
    Test the function to generate the annihilation operators.
    """

    def setUp(self) -> None:
        
        #generate the annihilation operators for 2
        self.annihilation_ops_twosite = annihilation_ops(n_ferms = 2)

        #generate the annihilation operators for 5 sites
        self.annihilation_ops = annihilation_ops(n_ferms = 5)
        

    def test_annihilation_ops(self):
        print("Testing the annihilation operators")
        #check the annihilation opeators for 2 sites explicitly:

        c_1 = np.zeros((4,4),dtype=np.complex_) 
        c_1[0,2] = 1
        c_1[1,3] = 1
        
        c_2 = np.zeros((4,4),dtype=np.complex_) 
        c_2[0,1] = 1
        c_2[2,3] = -1

        self.assertTrue(np.allclose(self.annihilation_ops_twosite[0],c_1), f"The first annihilation operator is not computed correctly,\n{c_1},\n{self.annihilation_ops_twosite[0]}\n{self.annihilation_ops_twosite[1]}\n{c_2}")
        self.assertTrue(np.allclose(self.annihilation_ops_twosite[1],c_2), f"The second annihilation operator is not computed correctly,\n{c_2},\n{self.annihilation_ops_twosite[1]}")
        
        #check internal consistency by comparing complicated many-body operators to operator generated by combination of annhilation operators
        #check 1:
        MB_op = many_body_operator(output_ferms=[1,0,0,1,0], input_ferms=[0,1,1,0,1]) 
        MB_op_check = self.annihilation_ops[0].T @ self.annihilation_ops[3].T @ self.annihilation_ops[1] @ self.annihilation_ops[2] @ self.annihilation_ops[4]

        #check 2:
        MB_op = many_body_operator(output_ferms=[1,0,1,1,0], input_ferms=[1,1,1,0,1]) 
        MB_op_check = self.annihilation_ops[0].T @ self.annihilation_ops[2].T @ self.annihilation_ops[3].T @ self.annihilation_ops[0] @ self.annihilation_ops[1] @ self.annihilation_ops[2] @ self.annihilation_ops[4]


        self.assertTrue(np.allclose(MB_op,MB_op_check), "The many-body operator is not computed correctly")

    def test_many_body_operator_sign(self):
        print("Testing the sign of the many-body operator")
        #create a string of annihilation operators and check that the reversed string has the correct sign        

        #check 1:
        #annihilation_string corresponding to "c_1 c_3 "
        fermion_string = [1,0,1]
        MB_op = many_body_operator(output_ferms=[0,0,0], input_ferms=fermion_string)
        MB_op_reverse = many_body_operator(output_ferms=fermion_string, input_ferms=[0,0,0]).T.conj()
        #here the sign should be +1 since there is even odd number of fermion pairs.
        #check that the many-body operator has the correct sign
        self.assertTrue(np.allclose(MB_op_reverse, - MB_op), f"The sign of the many-body operator is not computed correctly. Many-body operator should have the opposite sign fromthe original for reversed string. Operators are \n {MB_op} and \n{MB_op_reverse}")

        #check that the conjugate and non-conjugate operator string have the correct relationship to each other
        annihil_3 = annihilation_ops(n_ferms = 3)
        M_op_annihils = annihil_3[0] @ annihil_3[2]
        M_op_reverse_annihils = (annihil_3[0].T @ annihil_3[2].T).T
        self.assertTrue(np.allclose(M_op_annihils, MB_op), f"The sign of the many-body operator is not computed correctly. Many-body operator should have the same sign as the original for reversed string. Operators are \n {M_op_annihils} and \n{MB_op}")
        self.assertTrue(np.allclose(M_op_reverse_annihils, MB_op_reverse), f"The sign of the many-body operator is not computed correctly. Many-body operator should have the same sign as the original for reversed string. Operators are \n {M_op_reverse_annihils} and \n{MB_op_reverse}")
        self.assertTrue(np.allclose(M_op_annihils, - M_op_reverse_annihils), f"The sign of the many-body operator is not computed correctly. Many-body operator should have the same sign as the original for reversed string. Operators are \n {M_op_annihils} and \n{M_op_reverse_annihils}")


        #check 2: 
        #annihilation_string corresponding to "c_2 c_3 c_4 c_5 c_7"
        fermion_string = [0,1,1,1,1,0,1]
        MB_op = many_body_operator(output_ferms=[0,0,0,0,0,0,0], input_ferms=fermion_string)
        MB_op_reverse = many_body_operator(output_ferms=fermion_string, input_ferms=[0,0,0,0,0,0,0]).T.conj()
        #here the sign should be +1 since there is even odd number of fermion pairs.
        #check that the many-body operator has the correct sign
        self.assertTrue(np.allclose(MB_op_reverse, MB_op), f"The sign of the many-body operator is not computed correctly. Many-body operator should have the same sign as the original for reversed string. Operators are \n {MB_op} and \n{MB_op_reverse}")


        #check 3:
        #annihilation_string corresponding to "c_1 c_2 c_3 c_4 c_5 c_7"
        fermion_string = [1,1,1,1,1,0,1]
        MB_op = many_body_operator(output_ferms=[0,0,0,0,0,0,0], input_ferms=fermion_string)
        MB_op_reverse = many_body_operator(output_ferms=fermion_string, input_ferms=[0,0,0,0,0,0,0]).T.conj()
        #here the sign should be -1 since there is an odd number of fermion pairs.
        #check that the many-body operator has the correct sign
        self.assertTrue(np.allclose(MB_op_reverse, -MB_op), "The sign of the many-body operator is not computed correctly. Many-body operator should have the opposite sign of the original for reversed string")

class test_idx_signs_under_reverse(unittest.TestCase):
     
    def setUp(self) -> None:
        
        #generate the idx_signs_under_reverse for 4
        self.idx_signs_twosite = idx_sign_under_reverse(kernel_dim= 2**4)

        self.idx_signs_seven_site = idx_sign_under_reverse(kernel_dim= 2**7)
    
    def test_idx_signs_under_reverse(self):
        print("Testing the idx_signs_under_reverse")
        #check the idx_signs_under_reverse for 4 sites explicitly:
        idx_explicit = [3,5,6,7,9,10,11,12,13,14]
        self.assertTrue(np.allclose(self.idx_signs_twosite,idx_explicit), f"The idx_signs_under_reverse is not computed correctly,\n{idx_explicit},\n{self.idx_signs_twosite}")

    def test_many_body_operator_sign(self):
        print("Testing the sign of the many-body operator, part 2")
        #create a string of annihilation operators and check that the reversed string has the correct sign        

        #check 1:
        #annihilation_string corresponding to "c_2 c_3 c_4 c_5 c_7"
        fermion_string = [0,1,1,1,1,0,1]  
        # Convert the array of integers to a string
        binary_string = ''.join(str(bit) for bit in fermion_string)
        # Convert the binary string to a decimal integer
        decimal_integer = int(binary_string, 2)
        #check the decmail integer is INDEED contained in the idx_signs array
        self.assertTrue(decimal_integer not in self.idx_signs_seven_site, "The decimal integer is falsly contained in the idx_signs array")


        #check 2:
        #annihilation_string corresponding to "c_1 c_2 c_3 c_4 c_5 c_7"
        fermion_string = [1,1,1,1,1,0,1]
        # Convert the array of integers to a string
        binary_string = ''.join(str(bit) for bit in fermion_string)
        # Convert the binary string to a decimal integer
        decimal_integer = int(binary_string, 2)
        #check the decmail integer is INDEED contained in the idx_signs array
        self.assertTrue(decimal_integer in self.idx_signs_seven_site, "The decimal integer is not contained in the idx_signs array")
        
class test_indices_odd_even(unittest.TestCase):

    def setUp(self)-> None:
        
        #generate the indices with even and odd fermionic indices, respectively
        self.even_indices_foursite = np.array([0,3,5,6,9,10,12,15])
        self.odd_indices_foursite = np.array([1,2,4,7,8,11,13,14])
    
    def test_indices_odd_even(self):

        idc_odd, idc_even = indices_odd_and_even(2**4)
        print("Testing the indices_odd_even")
        #check the indices_odd_even for 4 sites explicitly:
        self.assertTrue(np.allclose(self.even_indices_foursite,idc_even), f"The even indices are not computed correctly,\n{self.even_indices_foursite},\n{idc_even}")
        self.assertTrue(np.allclose(self.odd_indices_foursite,idc_odd), f"The odd indices are not computed correctly,\n{self.odd_indices_foursite},\n{idc_odd}")

        #for seven fermions:
        idc_odd_7, idc_even_7 = indices_odd_and_even(2**7)
        for i in range (2**7):
            nbr_ones = bin(i).count("1")
            
            if nbr_ones % 2 == 0:
                self.assertTrue(i in idc_even_7, f"The index {i} is not contained in the even indices")
            else:
                self.assertTrue(i in idc_odd_7, f"The index {i} is not contained in the odd indices")

class test_fermion_parity(unittest.TestCase):

    def setUp(self)-> None:

        #generate the indices with even and odd fermionic indices, respectively
        self.idcs_odd_7, self.idcs_even_7 = indices_odd_and_even(2**7)

        #generate gates with even odd parity
        self.gate_odd = np.zeros((2**7,2**7),dtype=np.complex_)
        self.gate_even = np.zeros((2**7,2**7),dtype=np.complex_)
     

        self.gate_even[np.ix_(self.idcs_even_7, self.idcs_even_7)] = np.random.rand(len(self.idcs_even_7), len(self.idcs_even_7))
        self.gate_even[np.ix_(self.idcs_odd_7, self.idcs_odd_7)] = np.random.rand(len(self.idcs_odd_7), len(self.idcs_odd_7))
        self.gate_odd[np.ix_(self.idcs_even_7, self.idcs_odd_7)] = np.random.rand(len(self.idcs_even_7), len(self.idcs_odd_7))
        self.gate_odd[np.ix_(self.idcs_odd_7, self.idcs_even_7)] = np.random.rand(len(self.idcs_odd_7), len(self.idcs_even_7))

        #generate gate with no definite parity
        self.gate_no_parity = np.zeros((2**7,2**7),dtype=np.complex_)
        self.gate_no_parity[np.ix_(self.idcs_even_7, self.idcs_even_7)] = np.random.rand(len(self.idcs_even_7), len(self.idcs_even_7))
        self.gate_no_parity[np.ix_(self.idcs_even_7, self.idcs_odd_7)] = np.random.rand(len(self.idcs_even_7), len(self.idcs_odd_7))
        
    def test_fermion_parity(self):

        print("Testing the fermion_parity")
        #check the fermion_parity for 7 sites explicitly:
        self.assertTrue(np.allclose(fermion_parity(self.gate_odd),-1), f"The fermion parity is not computed correctly for the gate with odd parity, got {fermion_parity(self.gate_odd)}")
        self.assertTrue(np.allclose(fermion_parity(self.gate_even),1), f"The fermion parity is not computed correctly for the gate with even parity, got {fermion_parity(self.gate_even)}")
        #catch assertion error for gate with no definite parity
        with self.assertRaises(AssertionError):
            fermion_parity(self.gate_no_parity)

if __name__ == "__main__":
        unittest.main()